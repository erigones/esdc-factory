#!/usr/bin/bash
#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
#

#
# Copyright (c) 2017, Joyent, Inc.
# Copyright (c) 2017, Erigones, s. r. o.
#

# XXX - TODO
# - if $ntp_hosts == "local", configure ntp for no external time source

exec 4>>/var/log/prompt-config.log
echo "=== Starting prompt-config on $(tty) at $(date) ===" >&4
export PS4='{% raw %}[\D{%FT%TZ}] $(tty): ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }{% endraw %}'
export BASH_XTRACEFD=4
set -o xtrace

if [[ -z $(/bin/bootparams | grep "^smartos=true") ]]; then
	echo "This script should only be run on SmartOS"
	exit 1
fi

PATH=/usr/sbin:/usr/bin
export PATH

. /lib/svc/share/smf_include.sh

. /lib/sdc/config.sh
load_sdc_sysinfo
load_sdc_config

# ERRORS (for getanswer's errno)
ENOTFOUND=1
EBADJSON=2
EUNKNOWN=3

# Defaults
mail_to="root@localhost"
ntp_hosts="0.smartos.pool.ntp.org"
dns_resolver1="8.8.8.8"
dns_resolver2="8.8.4.4"
dns_domain="local"

# Globals
declare -a states
declare -a nics
declare -a assigned
declare prmpt_str
declare admin_iface_active
declare install_to_hdd
declare nicsup_done

# Additional NIC tags definitions
declare -A nictag_macs
declare -A nictag_ifaces
declare -A nictag_ips
declare -A nictag_netmasks
declare -A nictag_vlans
nictag_list="external internal storage"

advanced_install=0
nicsup_done=0

fatal()
{
	echo
	if [[ -n "$1" ]]; then
		echo "ERROR: $1"
	fi
	echo
	echo "System configuration failed, launching a shell."
	echo "You must reboot to re-run system configuration."
	echo "A log of setup may be found in /var/log/prompt-config.log"
	echo
	/usr/bin/bash
}


sig_doshell()
{
	echo
	echo
	echo "Bringing up a shell.  When you are done in the shell hit ^D to"
	echo "return to the system configuration tool."
	echo

	/usr/bin/bash

	echo
	echo "Resuming the system configuration tool."
	echo
	printf "$prmpt_str"
}

ip_to_num()
{
	IP=$1

	OLDIFS="$IFS"
	IFS="."
	set -- $IP
	num_a=$(($1 << 24))
	num_b=$(($2 << 16))
	num_c=$(($3 << 8))
	num_d=$4
	IFS="$OLDIFS"

	num=$((num_a + $num_b + $num_c + $num_d))
}

num_to_ip()
{
	NUM=$1

	fld_d=$(($NUM & 255))
	NUM=$(($NUM >> 8))
	fld_c=$(($NUM & 255))
	NUM=$(($NUM >> 8))
	fld_b=$(($NUM & 255))
	NUM=$(($NUM >> 8))
	fld_a=$NUM

	ip_addr="$fld_a.$fld_b.$fld_c.$fld_d"
}

#
# Converts an IP and netmask to their numeric representation.
# Sets the global variables IP_NUM, NET_NUM, NM_NUM and BCAST_ADDR to their
# respective numeric values.
#
ip_netmask_to_network()
{
	ip_to_num $1
	IP_NUM=$num

	ip_to_num $2
	NM_NUM=$num

	NET_NUM=$(($NM_NUM & $IP_NUM))

	ip_to_num "255.255.255.255"
	local bcasthost=$((~$NM_NUM & $num))
	BCAST_ADDR=$(($NET_NUM + $bcasthost))
}

# check if specified IP belongs to the subnet
ip_from_subnet() {
	local MYIP="$1"
	local NET="$2"
	local MASK="$3"

	ip_netmask_to_network "$NET" "$MASK"
	ip_to_num "$MYIP"

	if [[ "$num" -gt "$NET_NUM" && "$num" -lt "$BCAST_ADDR" ]]; then
		# $MYIP is from the subnet
		return 0
	else
		# not from subnet
		return 1
	fi
}

prompt_ip_from_subnet() {
	local MSG="$1"
	local DEFAULT="$2"
	local RESPONSE_KEY="$3"
	local NET="$4"
	local MASK="$5"

	while true; do
		echo
		promptnet "${MSG}" "${DEFAULT}" "${RESPONSE_KEY}"
		if ip_from_subnet "${val}" "${NET}" "${MASK}"; then
			# $val contains the correct response
			break
		else
			val=
			echo "Entered address does not belong to the ${NET}/${MASK} network!"
		fi
	done
}

# Sets two variables, USE_LO and USE_HI, which are the usable IP addrs for the
# largest block of available host addresses on the subnet, based on the two
# addrs the user has chosen for the GW and External Host IP.
# We look at the three ranges (upper, middle, lower) defined by the two addrs.
calc_ext_default_range()
{
	local a1=$1
	local a2=$2

	local lo=
	local hi=
	if [ $a1 -lt $a2 ]; then
		lo=$a1
		hi=$a2
	else
		lo=$a2
		hi=$a1
	fi

	u_start=$(($hi + 1))
	m_start=$(($lo + 1))
	l_start=$(($NET_NUM + 1))

	u_max=$(($BCAST_ADDR - 1))
	m_max=$(($hi - 1))
	l_max=$(($lo - 1))

	up_range=$(($u_max - $u_start))
	mid_range=$(($m_max - $m_start))
	lo_range=$(($l_max - $l_start))

	if [ $up_range -gt $mid_range ]; then
		USE_LO=$u_start
		USE_HI=$u_max
		range=$up_range
	else
		USE_LO=$m_start
		USE_HI=$m_max
		range=$mid_range
	fi

	if [ $range -lt $lo_range ]; then
		USE_LO=$l_start
		USE_HI=$l_max
	fi
}

# Tests whether entire string is a number.
isdigit()
{
	[ $# -eq 1 ] || return 1

	case $1 in
	*[!0-9]*|"") return 1;;
	*) return 0;;
	esac
}

# Tests network numner (num.num.num.num)
is_net()
{
	NET=$1

	OLDIFS="$IFS"
	IFS="."
	set -- $NET
	a=$1
	b=$2
	c=$3
	d=$4
	IFS="$OLDIFS"

	isdigit "$a" || return 1
	isdigit "$b" || return 1
	isdigit "$c" || return 1
	isdigit "$d" || return 1

	[ -z $a ] && return 1
	[ -z $b ] && return 1
	[ -z $c ] && return 1
	[ -z $d ] && return 1

	[ $a -lt 0 ] && return 1
	[ $a -gt 255 ] && return 1
	[ $b -lt 0 ] && return 1
	[ $b -gt 255 ] && return 1
	[ $c -lt 0 ] && return 1
	[ $c -gt 255 ] && return 1
	[ $d -lt 0 ] && return 1
	return 0
}

# Tests if input is an email address
is_email() {
	regex="^[a-z0-9!#\$%&'*+/=?^_\`{|}~-]+(\.[a-z0-9!#$%&'*+/=?^_\`{|}~-]+)*@([a-z0-9]([a-z0-9-]*[a-z0-9])?\.?)+[a-z0-9]([a-z0-9-]*[a-z0-9])?\$"
	ADDRESS=$1

	[[ $ADDRESS =~ $regex ]] && return 0
	return 1
}

# You can call this like:
#
#  value=$(getanswer "foo")
#  [[ $? == 0 ]] || fatal "no answer for question foo"
#
getanswer()
{
	local key=$1
	local answer=""
	local potential=""

	if [[ -z ${answer_file} ]]; then
		return ${ENOTFOUND}
	fi

	# json does not distingush between an empty string and a key that's not
	# there with the normal output, so we fix that so we can distinguish.
	answer=$(/usr/bin/cat ${answer_file} \
		| /usr/bin/json -e "if (this['${key}'] === undefined) this['${key}'] = '<<undefined>>';" \
		"${key}" 2>&1)
	if [[ $? != 0 ]]; then
		if [[ -n $(echo "${answer}" | grep "input is not JSON") ]]; then
			return ${EBADJSON}
		else
			return ${EUNKNOWN}
		fi
	fi

	if [[ ${answer} == "<<undefined>>" ]]; then
		return ${ENOTFOUND}
	fi

	echo "${answer}"
	return 0
}

# Optional input
promptopt()
{
	val=""
	def="$2"
	key="$3"

	if [[ -n ${key} ]]; then
		val=$(getanswer "${key}")
		if [[ $? == 0 ]]; then
			if [[ ${val} == "<default>" ]]; then
				val=${def}
			fi
			return
		fi
	fi

	if [ -z "$def" ]; then
		prmpt_str="$1 [press enter for none]: "
	else
		prmpt_str="$1 [$def]: "
	fi
	printf "$prmpt_str"
	read val
	# If def was null and they hit return, we just assign null to val
	[ -z "$val" ] && val="$def"
}

promptval()
{
	val=""
	def="$2"
	key="$3"

	if [[ -n ${key} ]]; then
		val=$(getanswer "${key}")
		if [[ ${val} == "<default>" && -n ${def} ]]; then
			val=${def}
			return
		fi
	fi

	while [ -z "$val" ]; do
		if [ -n "$def" ]; then
			prmpt_str="$1 [$def]: ${4}"
		else
			prmpt_str="$1: ${4}"
		fi
		printf "$prmpt_str"
		read val
		[ -z "$val" ] && val="$def"
		# Forward and back quotes not allowed
		echo $val | nawk '{
		    if (index($0, "\047") != 0)
		        exit 1
		    if (index($0, "`") != 0)
		        exit 1
		}'
		if [ $? != 0 ]; then
			echo "Single quotes are not allowed."
			val=""
			continue
		fi
		[ -n "$val" ] && break
		echo "A value must be provided."
	done
}

promptbool()
{
	val=""

	while [ /usr/bin/true ]; do
		promptval "$@"

		val=$(echo "${val}" | tr '[:upper:]' '[:lower:]')

		case "${val}" in
			"y"|"yes")
				val=1
				break
			;;
			"n"|"no")
				val=0
				break
			;;
			*)
				echo "The value must be 'yes' or 'no'."
			;;
		esac
	done
}

prompt_hostname() {
	while [ /usr/bin/true ]; do
		promptval "${@}"

		if [[ "${val}" == *"."* ]]; then
			break
		fi

		echo "A valid fully qualified domain name must be provided."
	done
}

prompt_host_ok_val()
{
	val=""
	def="$2"
	key="$3"

	if [[ -n ${key} ]]; then
		val=$(getanswer "${key}")
		if [[ ${val} == "<default>" && -n ${def} ]]; then
			val=${def}
		fi
	fi

	while [ -z "$val" ]; do
		if [ -n "$def" ]; then
			prmpt_str="$1 [$def]: "
		else
			prmpt_str="$1: "
		fi
		printf "$prmpt_str"
		read val
		[ -z "$val" ] && val="$def"
		if [ -n "$val" ]; then
			trap "" SIGINT
			printf "Checking connectivity..."
			ping -n $val 3 >/dev/null 2>&1
			if [ $? != 0 ]; then
				printf "UNREACHABLE\n"
			else
				printf "OK\n"
			fi
			trap sig_doshell SIGINT
			break
		else
			echo "A value must be provided."
		fi
	done
}

promptemail()
{
	val=""
	def="$2"
	key="$3"

	if [[ -n ${key} ]]; then
		val=$(getanswer "${key}")
		if [[ ${val} == "<default>" && -n ${def} ]]; then
			val=${def}
			is_email "$val" || val=""
		elif [[ -n ${val} ]]; then
			is_email "$val" || val=""
		fi
	fi

	while [ -z "$val" ]; do
		if [ -n "$def" ]; then
			prmpt_str="$1 [$def]: "
		else
			prmpt_str="$1: "
		fi
		printf "$prmpt_str"
		read val
		[ -z "$val" ] && val="$def"
		is_email "$val" || val=""
		[ -n "$val" ] && break
		echo "A valid email address must be provided."
	done
}

# Input must be a valid network number (see is_net())
promptnet()
{
	val=""
	def="$2"
	key="$3"

	if [[ -n ${key} ]]; then
		val=$(getanswer "${key}")
		if [[ ${val} == "<default>" && -n ${def} ]]; then
			val=${def}
		fi
		if [[ ${val} != "none" && ${val} != "dhcp" ]]; then
			is_net "$val" || val=""
		fi
	fi

	while [ -z "$val" ]; do
		if [ -n "$def" ]; then
			prmpt_str="$1 [$def]: "
		else
			prmpt_str="$1: "
		fi
		printf "$prmpt_str"
		read val
		[ -z "$val" ] && val="$def"
		if [[ ${val} != "none" && ${val} != "dhcp" ]]; then
			is_net "$val" || val=""
		fi
		[ -n "$val" ] && break
		echo "A valid network number (n.n.n.n) or 'dhcp' must be provided."
	done
}

printnics()
{
	i=1
	printf "%-6s %-9s %-18s %-7s %-10s\n" "Number" "Link" "MAC Address" \
	    "State" "Network"
	while [ $i -le $nic_cnt ]; do
		printf "%-6d %-9s %-18s %-7s %-10s\n" $i ${nics[$i]} \
		    ${macs[$i]} ${states[$i]} ${assigned[i]}
		((i++))
	done
}

# Must choose a valid NIC on this system
promptnic()
{
	tag=$(echo $1 | cut -d"'" -f2)
	if [[ -n ${tag} ]]; then
		mac=$(getanswer "${tag}_nic")
		if [[ -n ${mac} ]]; then
			for idx in ${!macs[*]}; do
				if [[ ${mac} == ${macs[${idx}]} ]]; then
					mac_addr="${macs[${idx}]}"
					val="${macs[${idx}]}"
					nic_val="${nics[${idx}]}"
					return
				fi
			done
		fi
	fi

	if [[ $nic_cnt -eq 1 ]]; then
		val="${macs[1]}"
		nic_val=${nics[1]}
		return
	fi

	printnics
	num=0
	while [ /usr/bin/true ]; do
		prmpt_str="Enter the number of the NIC for the ${tag} interface: "
		printf "$prmpt_str"
		read num
		if ! [[ "$num" =~ ^[0-9]+$ ]] ; then
				echo ""
		elif [[ $num -ge 1 && $num -le $nic_cnt ]]; then
				mac_addr="${macs[$num]}"
				clear_assigned_nictag "${tag}"

				if [[ "${assigned[$num]}" == "-" ]]; then
					assigned[$num]="${tag}"
				else
					assigned[$num]="${assigned[$num]},${tag}"
				fi
				nic_val=${nics[$num]}
				break
		fi
		# echo "You must choose between 1 and $nic_cnt."
		updatenicstates
		printnics
	done

	val=$mac_addr
}

# remove specified nic tag from all interfaces
clear_assigned_nictag() {
	tag="$1"
	for ifnum in $(seq 1 $nic_cnt); do
		assigned[$ifnum]="$(echo "${assigned[$ifnum]}" | sed -re "s/,?$tag//" -e 's/^,|,$//')"
		if [[ -z "${assigned[$ifnum]}" ]]; then
			assigned[$ifnum]="-"
		fi
	done
}

promptvlan()
{
	val=""
	msg="$1"
	def="$2"
	key="$3"

	while [ /usr/bin/true ]; do
		promptopt "${msg}" "${def}" "${key}"

		if [[ -z "${val}" || "${val}" == "none" ]]; then
			val=""
			break
		elif isdigit "${val}" && [[ "${val}" -eq 0 ]]; then
			val=""
			break
		elif isdigit "${val}" && [[ "${val}" -ge 1 && "${val}" -le 4095 ]]; then
			break
		fi

		echo "A valid VLAN ID (1-4095) or \"none\" or empty string must be provided."
	done
}

{% raw %}
promptpw()
{
	def="$3"
	key="$4"

	if [[ -n ${key} ]]; then
		preset_val=$(getanswer "${key}")
	fi

	trap "" SIGINT
	while [ /usr/bin/true ]; do
		val=""
		while [ -z "$val" ]; do
			if [[ -n ${preset_val} ]]; then
				val=${preset_val}
			else
				if [ -z "$def" ]; then
					printf "%s: " "$1"
				else
					printf "%s [enter to keep existing]: " "$1"
				fi
				stty -echo
				read val
				stty echo
				echo
			fi
			if [ -n "$val" ]; then
				if [ "$2" == "chklen" -a ${#val} -lt 6 ]; then
					echo "The password must be at least" \
						"6 characters long."
					val=""
					preset_val=""
				else
					break
				fi
			else
				if [ -n "$def" ]; then
					val=$def
					return
				else
					echo "A value must be provided."
				fi
			fi
		done

		cval=""
		while [ -z "$cval" ]; do
			if [[ -n ${preset_val} ]]; then
				cval=${preset_val}
			else
				printf "%s: " "Confirm password"
				stty -echo
				read cval
				stty echo
				echo
			fi
			[ -n "$cval" ] && break
			echo "A value must be provided."
		done

		[ "$val" == "$cval" ] && break

		echo "The entries do not match, please re-enter."
	done
	trap sig_doshell SIGINT
}
{% endraw %}

promptnictag_ip()
{
	val=""
	ntag="$1"

	promptbool "Add IP address on ${ntag} interface? (y/n)" "n" "${ntag}_addIP"
	if [[ "${val}" -eq 1 ]]; then
		valid=0
		while [ $valid -ne 1 ]; do
			promptnet "(${ntag}) IP address (or dhcp)" "${nictag_ips[${ntag}]}" "${ntag}_ip"
			nictag_ips["${ntag}"]="${val}"

			if [[ "${nictag_ips[${ntag}]}" != "dhcp" ]]; then
				# set default value for netmask
				[[ -z "${nictag_netmasks[${ntag}]}" ]] && nictag_netmasks[${ntag}]="255.255.255.0"
				# prompt user value for netmask (with default suggestion)
				promptnet "(${ntag}) Netmask" "${nictag_netmasks[${ntag}]}" "${ntag}_netmask"
				# save user value for netmask
				nictag_netmasks["${ntag}"]="${val}"

				# test netmask validity
				ip_netmask_to_network "${nictag_ips[${ntag}]}" "${nictag_netmasks[${ntag}]}"
				[ $IP_NUM -ne $BCAST_ADDR ] && valid=1
			else
				# DHCP will provide netmask
				nictag_netmasks["${ntag}"]="N/A"
				valid=1
			fi
			promptvlan "(${ntag}) VLAN ID" "${nictag_vlans[${ntag}]}" "${ntag}_vlan_id"
			nictag_vlans[${ntag}]="${val}"
		done
	else
		# clear IP from ntag
		unset nictag_ips["${ntag}"]
		unset nictag_netmasks["${ntag}"]
		unset nictag_vlans["${ntag}"]
	fi
}


updatenicstates()
{
	states=(1)
	#states[0]=1
	while IFS=: read -r link state ; do
		states=( ${states[@]-} $(echo "$state") )
	done < <(dladm show-phys -po link,state 2>/dev/null)
}

printheader()
{
	local newline=
	local cols=`tput cols`
	local subheader=$1

	if [[ $(getanswer "simple_headers") == "true" ]]; then
		echo "> ${subheader}"
		return
	fi

	if [ $cols -gt 80 ] ;then
		newline='\n'
	fi

	clear
	printf " %-40s\n" "Danube Cloud Setup"
	printf " %-40s%38s\n" "$subheader" "https://docs.danubecloud.org"
	for i in {1..80} ; do printf "-" ; done && printf "$newline"
}

print_warning()
{
	clear
	printf "WARNING\n"
	for i in {1..80} ; do printf "-" ; done && printf "\n"
	printf "\n$1\n"

	prmpt_str="\nPress [enter] to continue "
	printf "$prmpt_str"
	read continue
}

nicsup()
{
	[ $nicsup_done -eq 1 ] && return

	local vlan_opts=""

	if [[ -n "${admin_vlan_id}" && "${admin_vlan_id}" -ne 0 ]]; then
		admin_iface_active="admin0"
		dladm create-vnic -l ${admin_iface} -v ${admin_vlan_id} ${admin_iface_active}
		ifconfig ${admin_iface_active} plumb
	else
		ifconfig ${admin_iface} plumb 2> /dev/null
		admin_iface_active="${admin_iface}"
	fi

	if [[ "$admin_ip" == "dhcp" ]]; then
		ifconfig $admin_iface_active up
		ifconfig $admin_iface_active dhcp
	else
		ifconfig $admin_iface_active inet $admin_ip netmask $admin_netmask up
	fi

	# create an interface for each nic tag with defined IP address
	for ntag in "${!nictag_ips[@]}"; do
		if [ -n "${nictag_vlans[$ntag]}" ]; then
			vlan_opts="-v ${nictag_vlans[$ntag]}"
		fi
		dladm create-vnic -l "${nictag_ifaces[$ntag]}" $vlan_opts "${ntag}0"
		ifconfig "${ntag}0" plumb
		ifconfig "${ntag}0" inet "${nictag_ips[${ntag}]}" netmask "${nictag_netmasks[${ntag}]}" up
		vlan_opts=""	# clear for next iteration
	done

	if [[ -n ${headnode_default_gateway}
	    && ${headnode_default_gateway} != "none" ]]; then

		route add default $headnode_default_gateway >/dev/null
	fi

	nicsup_done=1
}

nicsdown()
{
	[ $nicsup_done -eq 0 ] && return

	ifconfig ${admin_iface_active} inet down unplumb

	if [[ -n "${admin_vlan_id}" && "${admin_vlan_id}" -ne 0 ]]; then
		dladm delete-vnic ${admin_iface_active}
	fi

	# delete interface for each nic tag with defined IP address
	for ntag in "${!nictag_ips[@]}"; do
		ifconfig "${ntag}0" inet down unplumb
		dladm delete-vnic "${ntag}0"
	done

	nicsup_done=0
}

printdisklayout()
{
  json -f "$1" | json -e '
    out = "vdevs:\n";
    disklist = [];
    for (var i = 0; i < vdevs.length; i++) {
      var x = vdevs[i];
      if (!x.type) {
        out += "   " + x.name + "\n";
        continue;
      }
      if (x.type === "mirror") {
        out += "   " + x.type + "  " + x.devices[0].name + " " +
          x.devices[1].name + "\n";
        continue;
      }
      out += "   " + x.type + "\n";
      var lout = "      ";
      for (var j = 0; j < x.devices.length; j++) {
        if ((lout + x.devices[j].name).length > 80) {
          out += lout + "\n";
          lout = "      " + x.devices[j].name + " ";
        } else {
          lout += x.devices[j].name + " ";
        }
      }
      out += lout + "\n";
    }
    if (typeof (spares) !== "undefined" && spares.length > 0) {
      out += "spares:\n";
      var lout = "      ";
      for (var i = 0; i < spares.length; i++) {
        if ((lout + spares[i].name).length > 80) {
          out += lout + "\n";
          lout += "      " + spares[i].name + " ";
        } else {
          lout += spares[i].name + " ";
        }
      }
      out += lout + "\n";
    }
    if (typeof (logs) !== "undefined" && logs.length > 0) {
      out += "logs:\n";
      var lout = "      ";
      for (var i = 0; i < logs.length; i++) {
        if ((lout + logs[i].name).length > 80) {
          out += lout + "\n";
          lout += "      " + logs[i].name + " ";
        } else {
          lout += logs[i].name + " ";
        }
      }
      out += lout + "\n";
    }
    out += "total capacity:   " + Number(capacity / 1073741824).toFixed(2)
      + " GB";
    ' out
}

promptpool()
{
	local layout=""
	local disks=
	while [[ /usr/bin/true ]]; do
		# Skip USB devices and the VMware boot image by default.
		diskinfo -Hp | nawk '
			$1 != "USB" {
				diskinfo = $0;
				bootdisk = 0;
				cmd = "fstyp -v /dev/dsk/" $2 "p1 2>/dev/null";
				while ((cmd | getline) > 0) {
					if ($0 ~ /^Volume Label:/ && $3 == "SMARTOSBOOT")
						bootdisk = 1;
				}
				close(cmd);
				if (bootdisk)
					next;
				print diskinfo;
			}' > /var/tmp/mydisks

		# We cannot suggest raidz layouts when installing on HDD
		if [[ "${install_to_hdd}" -eq 1 ]]; then
			mirror_candidates=$(disklist -s | nawk -F'=' '{ print $2 }' | sort | uniq -c | nawk '{ print $1 }' | grep -c "^2$")

			if [[ ${mirror_candidates} -ge 1 ]]; then
				layout="mirror"
			else
				layout="single"
			fi
		fi

		disklayout -f /var/tmp/mydisks $layout > /var/tmp/disklayout.json

		if [[ $? -ne 0 ]]; then
			#
			# There are two classes of errors that we need to
			# distinguish between. Those which are endemic to the
			# system itself and those which are as a result of a
			# user issue.  This is a bad way to tell these apart,
			# but for the moment this is the primary case.
			#
			if ! grep -q 'no primary storage disks' /var/tmp/disklayout.json; then
				cat /var/tmp/disklayout.json
				layout=""
				continue
			fi
			cat >&2 <<EOF

WARNING: failed to determine possible disk layout. It is possible that
the system detected no disks. We are launching a shell to allow you to
investigate the problem. Check for disks and their sizes with the
diskinfo(1M) command. If you do not see disks that you expect, please
determine your storage controller and contact you Danube Cloud partner or
reach out to the Danube Cloud community if you require assistence.

If you create or import a zpool named "zones" then installation will continue.
If you cannot, you should shutdown your system.

EOF
			/usr/bin/bash
			zpool list zones >/dev/null 2>/dev/null
			[[ $? -eq 0 ]] && return

			printheader "Storage"
			continue
		fi
		json error < /var/tmp/disklayout.json 2>/dev/null | grep . && layout="" && continue
		prmpt_str="$(printdisklayout /var/tmp/disklayout.json)\n\n"
		[[ -z "$layout" ]] && layout="default"
		prmpt_str+="This is the '${layout}' storage configuration.  To use it, type 'yes'.\n"
		prmpt_str+=" To see a different configuration, type: 'default', 'single', 'mirror'"
		if [[ "${install_to_hdd}" -eq 1 ]]; then
			prmpt_str+=".\n"
		else
			prmpt_str+=",\n'raidz1', 'raidz2', or 'raidz3'.\n"
		fi
		prmpt_str+=" To specify a manual configuration, type: 'manual'.\n\n"
		print $prmpt_str
		promptval "Selected zpool layout" "yes"

		if [[ $val == "single" || $val == "raidz" || $val == "raidz1" || $val == "raidz2" || $val == "raidz3" || $val == "mirror" ]]; then
			# go around again
			if [[ $val == "raidz" ]]; then
				layout="raidz1"
			else
				layout=$val
			fi
		elif [[ $val == "default" ]]; then
			layout=""
		elif [[ $val == "yes" ]]; then
			DISK_LAYOUT=/var/tmp/disklayout.json
			return
		elif [[ $val == "manual" ]]; then
			# let the user manually create the zpool
			layout=""
			DISK_LAYOUT="manual"
			echo "Launching a shell."
			echo "Please manually create/import a zpool named \"zones\"."
			echo "If you no longer wish to manually create a zpool,"
			echo "simply exit the shell."
			echo

			if [[ "${install_to_hdd}" -eq 1 ]]; then
				echo "If the layout suggested does not conform, please create zpool \"zones\" with"
				echo "appropriate layout (2-way mirror or single disk) manually with alternate root"
				echo "directory \"/.a\" and default dataset mount point \"/zones\" like:"
				echo
				echo "  zpool create -R /.a zones mirror c0t0d0 c1t0d0"
				echo
			else
				echo "If the layout suggested does not conform, please create zpool \"zones\" with"
				echo "appropriate layout manually with default dataset mount point \"/zones\" like:"
				echo
				echo "  zpool create zones mirror c0t0d0 c1t0d0"
				echo
			fi

			/usr/bin/bash
			zpool list zones >/dev/null 2>/dev/null
			[[ $? -eq 0 ]] && return
		else
			layout=""
		fi
	done
}

#
# The original setup capped the dumpvol at 4G, however this is too small for
# large memory servers.  This function will setup a dumpvol based on the size
# of the dumpadm -e estimate.
#
# We take the value and double it to ensure that we have an appropriately sized
# dumpvol out of the box.  We also set the smallest dumpvol to 1G.  The reason
# to double the estimate is this is the cleanest way to get a usable dump size
# on most systems. Setting the minimum to 1G should allow the dumpvol to work
# even on small ram setups without consuming too much disk space.
#
create_dump()
{
	local dumpsize=$(LC_ALL=C LANG=C dumpadm -e | awk '
		/Estimated dump size:/ {
			sz = $NF;
			outsz = 0;
			if (index(sz, "M") > 0) {
				outsz = sz * 1;
			} else if (index(sz, "G") > 0) {
				outsz = sz * 1024;
			}
		}
		END {
			outsz *= 2;
			printf("%d\n", outsz < 1024 ? 1024 : outsz);
		}
	')

	# Create the dump zvol
	zfs create -V ${dumpsize}mb -o checksum=noparity ${SYS_ZPOOL}/dump || \
	    fatal "failed to create the dump zvol"
	dumpadm -d /dev/zvol/dsk/${SYS_ZPOOL}/dump >/dev/null
	[[ $? -eq 0 ]] || fatal "failed to enable dump device"
}

#
# Setup the persistent datasets on the zpool.
#
setup_datasets()
{
	datasets=$(zfs list -H -o name | xargs)

	if [[ "${install_to_hdd}" -eq 1 ]]; then
		printf "==> Transferring image to HDD...\n"

		if [[ -d ${TMPROOT}/${SYS_ZPOOL} ]]; then
			zfs unmount ${SYS_ZPOOL}
			rmdir ${TMPROOT}/${SYS_ZPOOL}
		fi

		printf "%-56s" "Creating initial boot environment ${ROOTBE}... "
		zfs create -o mountpoint=legacy "${SYS_ZPOOL}/${ROOTDS}"
		platform_version=$(uname -v | sed -e 's|\(.*\)_\(.*\)|\2|')
		zfs create -o mountpoint=/ "${ROOTBE}"
		printf "%4s\n" "done"

		# Transfer root directory to new ROOTBE
		# Creating HDD boot structure

		printf "%-56s" "Transferring base OS files... "
		_oldwd=$(pwd)
		cd /
		(find bin boot dev devices etc kernel lib opt platform root sbin smartdc usr | cpio -pdmuq "${TMPROOT}") || \
			fatal "Failed to transfer system to HDD"
		cd "${_oldwd}"
		printf "%4s\n" "done"

		printf "%-56s" "Creating auxiliary directories... "
		mkdir -p ${TMPROOT}/system/{boot,contract,object}
		mkdir ${TMPROOT}/tmp && chmod 1777 ${TMPROOT}/tmp
		mkdir ${TMPROOT}/proc
		mkdir ${TMPROOT}/mnt
		mkdir ${TMPROOT}/${SYS_ZPOOL}
		mkdir -p ${TMPROOT}/os > /dev/null 2>/dev/null
		mkdir -p ${TMPROOT}/platform/i86pc/amd64 > /dev/null 2>/dev/null
		printf "%4s\n" "done"

		printf "%-56s" "Transferring platform image... "
		/usr/bin/rsync -aq ${USBMNT}/os/${platform_version}/platform/i86pc/amd64 ${TMPROOT}/platform/i86pc || \
			fatal "Failed to transfer platform image"
		printf "%4s\n" "done"

		printf "%-56s" "Mounting default dataset ${SYS_ZPOOL}... "
		zfs mount ${SYS_ZPOOL} > /dev/null 2>/dev/null
		printf "%4s\n" "done"

		printf "==> Transferred image to HDD\n"
	fi

	if ! echo $datasets | grep dump > /dev/null; then
		printf "%-56s" "Making dump zvol... "
		create_dump
		printf "%4s\n" "done"
	fi

	if ! echo $datasets | grep ${CONFDS} > /dev/null; then
		printf "%-56s" "Initializing config dataset for zones... "
		zfs create ${CONFDS} || fatal "failed to create the config dataset"
		chmod 755 ${TMPROOT}/${CONFDS}
		cp -p ${TMPROOT}/etc/zones/* ${TMPROOT}/${CONFDS}
		zfs set mountpoint=legacy ${CONFDS}
		printf "%4s\n" "done"
	fi

	if ! echo $datasets | grep ${USBKEYDS} > /dev/null; then
		printf "%-56s" "Creating config dataset... "
		zfs create -o mountpoint=legacy ${USBKEYDS} || \
		  fatal "failed to create the config dataset"
		mkdir /usbkey > /dev/null 2>/dev/null
		mount -F zfs ${USBKEYDS} /usbkey
		printf "%4s\n" "done"
	fi

	if ! echo $datasets | grep ${COREDS} > /dev/null; then
		printf "%-56s" "Creating global cores dataset... "
		zfs create -o quota=10g -o mountpoint=/${SYS_ZPOOL}/global/cores \
			-o compression=gzip ${COREDS} || \
				fatal "failed to create the cores dataset"
		printf "%4s\n" "done"
	fi

	if ! echo $datasets | grep ${OPTDS} > /dev/null; then
		printf "%-56s" "Creating opt dataset... "
		zfs create -o mountpoint=legacy ${OPTDS} || \
			fatal "failed to create the opt dataset"
		printf "%4s\n" "done"
	fi

	if ! echo $datasets | grep ${VARDS} > /dev/null; then
		printf "%-56s" "Initializing var dataset... "

		if [[ "${install_to_hdd}" -eq 1 ]]; then
			vardest="/var"
		else
			vardest="/${VARDS}"
		fi

		zfs create -o mountpoint=${vardest} ${VARDS} || \
			fatal "failed to create the var dataset"
		chmod 755 ${TMPROOT}/${vardest}

		cd /var || fatal "/var does not exist"
		if ( ! find . -print | cpio -pdm ${TMPROOT}/${vardest} 2>/dev/null ); then
			fatal "failed to initialize the var directory"
		fi

        if [[ "${install_to_hdd}" -eq 1 ]]; then
			zfs set canmount=noauto ${VARDS}
		else
			zfs set mountpoint=legacy ${VARDS}
		fi

		printf "%4s\n" "done"
	fi

	if ! echo $datasets | grep ${SWAPVOL} > /dev/null; then
		printf "%-56s" "Creating swap zvol... "

		#
		# We cannot allow the swap size to be less than the size of
		# DRAM, lest we run into the availrmem double accounting
		# issue for locked anonymous memory that is backed by
		# in-memory swap (which will severely and artificially limit
		# VM tenancy).  We will therfore not create a swap device
		# smaller than DRAM -- but we still allow for the
		# configuration variable to account for actual consumed space
		# by using it to set the refreservation on the swap volume
		# if/when the specified size is smaller than DRAM.
		#

		size=${SYSINFO_MiB_of_Memory}
		zfs create -V ${size}mb ${SWAPVOL} || fatal \
		    "failed to create swap partition"

		swap -a /dev/zvol/dsk/${SWAPVOL}
		printf "%4s\n" "done"
	fi

	if ! echo $datasets | grep ${BACKUPDS} > /dev/null; then
		printf "%-56s" "Creating backup dataset... "
		zfs create ${BACKUPDS} || fatal "failed to create the backup dataset"
		zfs create -o compression=lz4 ${BACKUPDS}/file || fatal "failed to create file backup dataset"
		zfs create -o compression=lz4 ${BACKUPDS}/ds || fatal "failed to create dataset backup dataset"
		zfs create -o compression=lz4 ${BACKUPDS}/manifests || fatal "failed to create manifests backup dataset"
		printf "%4s\n" "done"
	fi

	if ! echo $datasets | grep ${ISODS} > /dev/null; then
		printf "%-56s" "Creating ISO dataset... "
		zfs create -o mountpoint=/iso ${ISODS} || fatal "failed to create the ISO dataset"
		zfs set atime=on ${ISODS} || fatal "failed to set atime=on for ${ISODS}"
		printf "%4s\n" "done"
	fi

	if [[ "${install_to_hdd}" -eq 1 ]]; then
		printf "%-56s" "Transferring USB drive contents to HDD... "
		/usr/bin/rsync -a ${USBMNT}/ /usbkey/ || fatal "Failed to transfer"
		printf "%4s\n" "done"

		# Create placeholder directory
		mkdir -p "${TMPROOT}/${SYS_ZPOOL}/boot/grub"
		printf "%-56s" "Activating boot environment ${DEFBE}... "
		/usr/sbin/beadm activate -v "${DEFBE}" >&4 2>&4 || fatal "Failed to activate"
		printf "%4s\n" "done"

		echo 'boot-args="-B smartos=true,computenode=true"' >> ${TMPROOT}/boot/loader.conf
		echo "7.0" > ${TMPROOT}/.smartdc_version
	fi
}

create_zpool()
{
	layout=$1
	disks=$2
	pool=zones

	# If the pool already exists, don't create it again.
	if /usr/sbin/zpool list -H -o name $pool >/dev/null 2>/dev/null; then
		printf "%-56s\n" "Pool '$pool' exists, skipping creation... "
		return 0
	fi

	printf "%-56s" "Creating pool $pool... "

	if [[ "${install_to_hdd}" -eq 1 ]]; then
		rpoolarg="-R ${TMPROOT}"
	else
		rpoolarg=""
	fi

	# If this is not a manual layout, then we've been given
	# a JSON file describing the desired pool, so use that:
	mkzpool -f ${rpoolarg} "${pool}" "${layout}" || \
	    fatal "failed to create pool ${pool}"

	zfs set atime=off ${pool} || \
	    fatal "failed to set atime=off for pool ${pool}"

	printf "%4s\n" "done"
}

create_zpools()
{
	layout=$1
	devs=$2

	export SYS_ZPOOL="zones"
	export CONFDS=${SYS_ZPOOL}/config
	export COREDS=${SYS_ZPOOL}/cores
	export OPTDS=${SYS_ZPOOL}/opt
	export VARDS=${SYS_ZPOOL}/var
	export USBKEYDS=${SYS_ZPOOL}/usbkey
	export SWAPVOL=${SYS_ZPOOL}/swap
	export BACKUPDS=${SYS_ZPOOL}/backups
	export ISODS=${SYS_ZPOOL}/iso

	export TMPROOT=""
	export DEFBE=dcos-1
	export ROOTDS=ROOT
	export ROOTBE=${SYS_ZPOOL}/${ROOTDS}/${DEFBE}

	if [[ "${install_to_hdd}" -eq 1 ]]; then
		export VARDS="${ROOTBE}/var"
		export TMPROOT="/.a"
		mkdir -p "${TMPROOT}" > /dev/null 2>/dev/null
	fi

	create_zpool "$layout" "$devs"
	sleep 5

	svccfg -s svc:/system/smartdc/init setprop config/zpool="${SYS_ZPOOL}"
	svccfg -s svc:/system/smartdc/init:default refresh

	setup_datasets
	#
	# Since there may be more than one storage pool on the system, put a
	# file with a certain name in the actual "system" pool.
	#
	touch ${TMPROOT}/${SYS_ZPOOL}/.system_pool
}

{% if usb_type != "hn" %}
check_cfgdb()
{
	trap "" SIGINT
	printf "Checking cfgdb availability..."
	echo "ruok" | nc -n -w 10 "${cfgdb_admin_ip}" 2181 2> /dev/null | grep imok >/dev/null 2>&1
	ec=$?

	if [[ "${ec}" -eq 0 ]]; then
		printf "OK\n"
	else
		printf "UNAVAILABLE\n"
	fi

	trap sig_doshell SIGINT
	return "${ec}"
}

query_cfgdb()
{
	local zkcli="${USBMNT}/scripts/zookeepercli"

	trap "" SIGINT
	printf "Accessing cfgdb..."
	datacenter_name=$("${zkcli}" -servers "${cfgdb_admin_ip}:2181" -auth_usr "esdc" \
		-auth_pwd "${esdc_install_password}" -c get /esdc/settings/dc/datacenter_name 2>/var/tmp/zk-error)
	ec=$?

	if [[ "${ec}" -eq 0 ]]; then
		printf "OK\n"
	else
		printf "ERROR ($(nawk -F 'zk: ' '{ print $2 }' /var/tmp/zk-error))\n"
	fi

	trap sig_doshell SIGINT
	return "${ec}"
}
{% endif %}

# EULA
printeula()
{
	local eula_txt="${USBMNT}/eula.txt"
	local eula_pager="${USBMNT}/scripts/pager.sh"

	if [[ ! -f "${eula_txt}" || ! -f "${eula_pager}" ]]; then
		echo "ERROR: EULA file '${eula_txt}' or EULA reader '${eula_pager}' does not exist!"
		exit 1
	fi

	"${eula_pager}" "${eula_txt}"
}

prompteula()
{
	echo
	promptval "By typing 'accept' you agree with the terms of this software
license agreement, 'reject' to cancel or 'print' to print it again." "print" "eula" "\n"

	case "${val}" in
		"accept")
			:
		;;
		"print"|"p")
			printeula
			prompteula
		;;
		"reject"|"cancel")
			echo "EULA was not accepted. The system is going for halt now!"
			sleep 5
			halt
		;;
		*)
			prompteula
		;;
	esac
}


trap "" SIGINT

while getopts "f:" opt
do
	case "$opt" in
		f)	answer_file=${OPTARG};;
	esac
done

shift $(($OPTIND - 1))

USBMNT=$1

if [[ -n ${answer_file} ]]; then
	if [[ ! -f ${answer_file} ]]; then
		echo "ERROR: answer file '${answer_file}' does not exist!"
		exit 1
	fi
elif [[ -f ${USBMNT}/private/answers.json ]]; then
	answer_file=${USBMNT}/private/answers.json
fi

#
# Get local NIC info
#
nic_cnt=0

while IFS=: read -r link addr ; do
	((nic_cnt++))
	nics[$nic_cnt]=$link
	macs[$nic_cnt]=`echo $addr | sed 's/\\\:/:/g'`
	# reformat the nic so that it's in the proper 00:00:ab... form not 0:0:ab...
	macs[$nic_cnt]=$(printf "%02x:%02x:%02x:%02x:%02x:%02x" \
	    $(echo "${macs[${nic_cnt}]}" \
	    | tr ':' ' ' | sed -e "s/\([A-Fa-f0-9]*\)/0x\1/g"))
	assigned[$nic_cnt]="-"
done < <(dladm show-phys -pmo link,address 2>/dev/null)

if [[ $nic_cnt -lt 1 ]]; then
	echo "ERROR: cannot configure the system, no NICs were found."
	exit 0
fi

# Don't do an 'ifconfig -a' - this causes some nics (bnx) to not
# work when combined with the later dladm commands
for iface in $(dladm show-phys -pmo link); do
	ifconfig $iface plumb 2>/dev/null
done
updatenicstates

export TERM=xterm-color
stty erase ^H

trap sig_doshell SIGINT

printheader "Danube Cloud"

message="
You must answer the following questions to configure your Danube Cloud node.
You will have a chance to review and correct your answers, as well as a
chance to edit the final configuration, before it is applied.

At the prompts, if you type ^C you will be placed into a shell. When you
exit the shell the configuration process will resume from where it was
interrupted.

Press [enter] to continue"

if [[ $(getanswer "skip_instructions") != "true" ]]; then
	printf "$message"
fi

console=$(getanswer "config_console")
# If we've asked for automatic configuration, but are not running on the
# primary boot console (as selected in the bootloader menu), then pause at a
# prompt:
if [[ -z ${console} || $(tty) != "/dev/console" ]]; then
	read continue;
fi

if [ -f /tmp/config_in_progress ]; then
	message="
Configuration is already in progress on another terminal.
This session can no longer perform system configuration.\n"
	while [ /usr/bin/true ]; do
		printf "$message"
		read continue;
	done

fi
touch /tmp/config_in_progress

printheader "EULA"
printeula
prompteula


printheader "Advanced Installation"
message="
The advanced installation will allow you to customize additional network
options, such as VLANs, multiple IP addresses, NTP servers, etc.
Basic installation is sufficient for most installations.\n\n"

if [[ $(getanswer "skip_instructions") != "true" ]]; then
	printf "$message"
fi
promptbool "Enable advanced installation? (y/n)" "n" "advanced_install"
advanced_install=${val}

#
# Main loop to prompt for user input
#
while [ /usr/bin/true ]; do

{% if usb_type == "hn" %}
	printheader "Datacenter Information"
	message="
The following questions will ask some information about your datacenter
and Danube Cloud installation.\n\n"

	if [[ $(getanswer "skip_instructions") != "true" ]]; then
		printf "$message"
	fi

	promptval "Enter DC name" "${datacenter_name}" "datacenter_name"
	datacenter_name="$val"
{% endif %}

	printheader "Networking"
	message="
To set up networking you must first configure network tags. A network tag
refers to a physical NIC or an aggregation. Virtual machines will be created on
top of a network tag. Setup will first create an admin network tag and
configure a NIC so that you can access the Danube Cloud node. Then you will
have the option to create additional network tags and to configure
additional NICs for accessing the compute node or virtual machines.

Press [enter] to continue"

	if [[ $(getanswer "skip_instructions") != "true" ]]; then
		printf "$message"
		prmpt_str="\nPress [enter] to continue configuring the admin network"
		read continue
	fi

	printheader "Networking - Admin"
	message="
The admin network is used for management purposes and communication between
compute nodes in Danube Cloud. It is the default network that is created.
The configured NIC will be used to access the compute node.\n\n"

	if [[ $(getanswer "skip_instructions") != "true" ]]; then
		printf "$message"
	fi

	promptnic "'admin'"
	admin_nic="$val"
	admin_iface="$nic_val"

	if [[ "${nic_cnt}" -eq 1 ]]; then
		printf "Autoselected NIC: ${admin_iface}\n\n"
	fi

	valid=0
	while [ $valid -ne 1 ]; do
		promptnet "(admin) IP address (or dhcp)" "$admin_ip" "admin_ip"
		admin_ip="$val"

		if [[ "$admin_ip" != "dhcp" ]]; then
			[[ -z "$admin_netmask" ]] && \
			    admin_netmask="255.255.255.0"

			promptnet "(admin) Netmask" "$admin_netmask" "admin_netmask"
			admin_netmask="$val"
			ip_netmask_to_network "$admin_ip" "$admin_netmask"
			[ $IP_NUM -ne $BCAST_ADDR ] && valid=1
		else
			valid=1
		fi
	done

	if [[ ${advanced_install} -eq 1 ]]; then
		promptvlan "(admin) VLAN ID" "$admin_vlan_id" "admin_vlan_id"
		admin_vlan_id="$val"
	else
		admin_vlan_id=""
	fi

	printheader "Networking - Network tags"
	message="
By using additional network tags, you can easily identify multiple physical
network interconnections between compute nodes.
There are $(echo $nictag_list | wc -w | tr -d "[:space:]") configurable network tags:
$nictag_list

One physical NIC can have multiple network tags.
The tags can be added or modified also later by the nictagadm command.\n\n"

	if [[ $(getanswer "skip_instructions") != "true" ]]; then
		printf "$message"
	fi

	# don't repeat selecting nic tags if they already have been defined in previous run
	if [[ -z "${!nictag_macs[@]}" ]]; then
		promptbool "Add another network tag? (y/n)" "y" "add_nictags"
	else
		promptbool "Modify network tags? (y/n)" "n" "add_nictags"
	fi
		printf "\n"

	if [[ "${val}" -eq 1 ]]; then
		for ntag in $nictag_list; do
			promptbool "Add NIC tag \"${ntag}\"? (y/n)" "n" "${ntag}_addtag"
			if [[ "${val}" -eq 1 ]]; then
				promptnic "'${ntag}'"
				nictag_macs[${ntag}]="${val}"
				nictag_ifaces[${ntag}]="$nic_val"

				if [[ $nic_cnt -eq 1 ]]; then
					# just print info (we have only one NIC)
					printf "\nAutoselected NIC ${nic_val}\n\n"
				fi

				if [[ ${advanced_install} -eq 1 ]]; then
					# ask if user wants to set IP over the NIC tag
					promptnictag_ip "${ntag}"
				fi
			else
				# clear ${ntag}
				unset nictag_macs["${ntag}"]
				unset nictag_ifaces["${ntag}"]
				unset nictag_ips["${ntag}"]
				unset nictag_netmasks["${ntag}"]
				unset nictag_vlans["${ntag}"]
				# clear assigned nictag from the list
				clear_assigned_nictag "$ntag"
			fi
		done
	fi

	printheader "Networking - default gateway"
	message="
The default gateway will determine which router will be used to connect
this compute node to other networks. This will almost certainly be the router
connected to your 'admin' network. Use 'none' if you have no gateway
or you rely only on the dhcp.\n\n"

	if [[ $(getanswer "skip_instructions") != "true" ]]; then
		printf "$message"
	fi

	# default to external_gateway if that's set, if not, use 'none'
	[[ -z "$headnode_default_gateway" && -n ${external_gateway} ]] && \
		headnode_default_gateway="$external_gateway"
	if [[ -z "$headnode_default_gateway" && "$admin_ip" != "dhcp" ]]; then
		# re-assign admin IPs to global variables and set default suggestion
		ip_netmask_to_network "$admin_ip" "$admin_netmask"
		headnode_default_gateway="$(num_to_ip $((NET_NUM+1)); echo $ip_addr)"
	fi
	[[ -z "$headnode_default_gateway" ]] && \
		headnode_default_gateway="none"

	promptnet "Enter the default gateway IP" "$headnode_default_gateway" "headnode_default_gateway"
	headnode_default_gateway="${val}"
	# if headnode_default_gateway is outside the admin subnet,
	# we need to ask for the admin gw
	if ! ip_from_subnet "$headnode_default_gateway" "$admin_ip" "$admin_netmask"; then
		if [ -z "$admin_gateway" ]; then
			# set default value
			admin_gateway=$(num_to_ip $(($NET_NUM + 1)) && echo $ip_addr)
		fi
		prompt_ip_from_subnet "Enter the default gateway of the admin network"\
			"$admin_gateway" admin_gateway "$admin_ip" "$admin_netmask"
		admin_gateway="${val}"
	else
		admin_gateway="$headnode_default_gateway"
	fi

	# Bring the admin and external nics up now: they need to be for the
	# connectivity checks in the next section
	printf "\nBringing up the network interfaces...\n\n"
	nicsup
	# We need to slowdown here because if we jump too fast to the next section
	# the network checks below may fail (true story)
	sleep 3

	message="
The DNS servers set here will be used to provide name resolution abilities to
the compute node itself. These DNS servers are independent of anything
you use to create virtual machines through Danube Cloud.\n\n"

	if [[ $(getanswer "skip_instructions") != "true" ]]; then
		printf "$message"
	fi

	if [[ ${advanced_install} -eq 1 ]]; then
		prompt_host_ok_val "Enter the Primary DNS server IP" "$dns_resolver1" "dns_resolver1"
		dns_resolver1="$val"
		prompt_host_ok_val "Enter the Secondary DNS server IP" "$dns_resolver2" "dns_resolver2"
		dns_resolver2="$val"
		promptval "\nDefault DNS search domain" "$dns_domain" "dns_search"
		dns_domain="$val"
	else
		# leaving default settings
		printf "Setting first DNS server to $dns_resolver1\n"
		printf "Setting second DNS server to $dns_resolver2\n"
		printf "Setting DNS search domain to $dns_domain\n"
	fi
	cat > /etc/resolv.conf <<EOF
nameserver $dns_resolver1
nameserver $dns_resolver2
EOF
	if [[ -n "${dns_domain}" ]]; then
		echo "search ${dns_domain}" >> /etc/resolv.conf
	fi

	if [[ ${advanced_install} -eq 1 ]]; then
		message="
By default the first compute node acts as an NTP server for the admin network.
You can set the first compute node to be an NTP client to synchronize to
another NTP server.\n"

		if [[ $(getanswer "skip_instructions") != "true" ]]; then
			printf "$message"
		fi

		prompt_host_ok_val "Enter an NTP server IP address or hostname" "$ntp_hosts" "ntp_host"
		ntp_hosts="$val"
	else
		# leaving default settings
		printf "Setting NTP server to $ntp_hosts\n"
	fi

	skip_ntp=$(getanswer "skip_ntp_check")
	if [[ -z ${skip_ntp} || ${skip_ntp} != "true" ]]; then
			printf "Synchronizing time...\n"
			ntpdate -b $ntp_hosts >/dev/null 2>&1
			[ $? != 0 ] && print_warning "NTP failure setting date and time"
	fi


	# START: Danube Cloud install to HDD addition
	printheader "Installation to disk"

	message="\n"

	if [[ $(getanswer "skip_instructions") != "true" ]]; then
		printf "$message"
	fi

	[[ "${install_to_hdd}" -eq 1 ]] && install_to_hdd_def="y" || install_to_hdd_def="n"
	promptbool "Install to HDD instead of booting from USB? (y/n)" "${install_to_hdd_def}" "install_to_hdd"
	install_to_hdd=${val}
	# END: Danube Cloud install to HDD addition


	printheader "Storage"

	message="
Setup will automatically determine what we think is
the best zpool layout from your current disks. You may use this
suggestion, change to another built in storage profile, or simply create
your own zpool.

If you plan to install to hard drive, please use the profile 'single' or
'mirror'. Booting from striped-mirror or raidz is not supported.\n\n"

	if [[ $(getanswer "skip_instructions") != "true" ]]; then
		printf "$message"
	fi

	promptpool


	# START: Danube Cloud management configuration
	printheader "System Configuration"
	message="
Setup will now go through and prompt for final pieces of account configuration.
This includes setting the root password for the compute node and optionally
setting a hostname.\n\n"

	if [[ $(getanswer "skip_instructions") != "true" ]]; then
		printf "$message"
	fi

	promptpw "Enter root password" "nolen" "$root_shadow" "root_password"
	root_shadow="$val"

{% if usb_type == "hn" %}
	[[ -z "$hostname" && -z "$dns_domain" ]] && hostname="node01.local"
	[[ -z "$hostname" ]] && hostname="node01.$dns_domain"
{% else %}
	[[ -z "$hostname" && -z "$dns_domain" ]] && hostname="node02.local"
	[[ -z "$hostname" ]] && hostname="node02.$dns_domain"
{% endif %}
	prompt_hostname "Enter system hostname" "$hostname" "hostname"
	hostname="$val"


	printheader "Danube Cloud Management Services"
{% if usb_type == "hn" %}
	message="
The IP address set here will host the web administration portal of your
Danube Cloud installation. This IP address will also be used as a basis
for enumerating other Danube Cloud administrative zones' networking.
Five IP addresses following the management portal IP address will be used
for Danube Cloud service zones. Please make sure that the IP addresses are
available for automatic allocation.\n\n"
{% else %}
	message="
Every compute node in Danube Cloud has to be connected to the management VM.
In order to determine the configuration of your Danube Cloud installation
the installer must connect to the primary configuration database and fetch
all required settings. This ensures that you can manage the node from the
web management.\n\n"
{% endif %}
	if [[ $(getanswer "skip_instructions") != "true" ]]; then
		printf "$message"
	fi

{% if usb_type == "hn" %}
	if [[ -z "${mgmt_admin_ip}" ]]; then
		ip_netmask_to_network "${admin_ip}" "${admin_netmask}"
		next_addr=$(($IP_NUM + 1))
		num_to_ip ${next_addr}
		mgmt_admin_ip="${ip_addr}"
	fi

	promptnet "Management portal IP address" "${mgmt_admin_ip}" "mgmt_admin_ip"
	mgmt_admin_ip="${val}"
{% else %}
	prompt_host_ok_val "Configuration database IP address" "${cfgdb_admin_ip}" "cfgdb_admin_ip"
	cfgdb_admin_ip="${val}"
	skip_cfgdb_check=$(getanswer "skip_cfgdb_check")
	[[ -z ${skip_cfgdb_check} || ${skip_cfgdb_check} != "true" ]] && check_cfgdb
{% endif %}

	echo

{% if usb_type == "hn" %}
	message="
Please choose a password that will protect your Danube Cloud data center
configuration settings. This password will be required whenever you
install an additional compute node into your data center.\n\n"
{% else %}
	message="
Please enter the Configuration master password that was used during
the first compute node installation.\n\n"
{% endif %}

	if [[ $(getanswer "skip_instructions") != "true" ]]; then
		printf "$message"
	fi

{% if usb_type == "hn" %}
	promptpw "Enter configuration master password" "chklen" "${esdc_install_password}" "esdc_install_password"
	esdc_install_password="${val}"
{% else %}
	promptpw "Enter configuration master password" "nolen" "${esdc_install_password}" "esdc_install_password"
	esdc_install_password="${val}"
	if [[ -z ${skip_cfgdb_check} || ${skip_cfgdb_check} != "true" ]]; then
		if ! query_cfgdb; then  # This will set the datacenter_name
			print_warning "Failed to read data from the configuration database"
		fi
	fi
{% endif %}

{% if usb_type == "hn" %}
	printheader "Administrator's e-mail address"

	message="
Administrator's e-mail address for receiving system-generated messages and
monitoring alerts.\n\n"

	if [[ $(getanswer "skip_instructions") != "true" ]]; then
		printf "$message"
	fi

	promptemail "Enter administrator's e-mail address" "${admin_email}" "admin_email"
	admin_email="${val}"
{% endif %}
	# END: Danube Cloud management configuration

	# Bring the admin and external nics down now: we don't need them anymore
	nicsdown

	printheader "Verify Configuration"
	message="
Please verify your Danube Cloud compute node configuration. After this point
the system will be set up and all data on the disks will be erased.\n\n"

	if [[ $(getanswer "skip_instructions") != "true" ]]; then
		printf "$message"
	fi

	if [[ $(getanswer "skip_final_summary") != "true" ]]; then
		echo
		printf "%8s %17s %15s %15s %15s\n" "Net" "MAC" "IP addr." "Netmask" "VLAN ID"
		if [[ "$admin_ip" == "dhcp" ]]; then
			printf "%8s %17s %15s %15s %15s\n" "admin" $admin_nic $admin_ip "N/A" $admin_vlan_id
		else
			printf "%8s %17s %15s %15s %15s\n" "admin" $admin_nic $admin_ip $admin_netmask $admin_vlan_id
		fi
		for ntag in "${!nictag_macs[@]}"; do
			printf "%8s %17s %15s %15s %15s\n" "$ntag" ${nictag_macs[$ntag]} ${nictag_ips[$ntag]} ${nictag_netmasks[$ntag]} ${nictag_vlans[$ntag]}
		done
		echo
		printf "DNS Servers: (%s, %s)\n" "$dns_resolver1" "$dns_resolver2"
		printf "Search Domain: %s\n" "$dns_domain"
		printf "Hostname: %s\n" "$hostname"
		printf "Default gateway: %s\n" "$headnode_default_gateway"
		printf "NTP server: %s\n" "$ntp_hosts"
		echo
		[[ "${install_to_hdd}" -eq 1 ]] && tohdd="Yes" || tohdd="No"
		printf "Install to HDD: %s\n" "${tohdd}"
		echo
		printf "Datacenter name: %s\n" "$datacenter_name"
{% if usb_type == "hn" %}
		printf "Management portal IP address: %s\n" "${mgmt_admin_ip}"
		printf "Administrator's e-mail address: %s\n" "${admin_email}"
{% else %}
		printf "Configuration database IP address: %s\n" "${cfgdb_admin_ip}"
{% endif %}
		echo
	fi

	if [[ $(getanswer "skip_final_confirm") != "true" ]]; then
		promptbool "Is this correct, proceed with installation? (y/n)" "y"
		if [[ "${val}" -eq 1 ]]; then
			clear
			break
		fi
	else
		break
	fi
done

echo "==> Initializing new system..."

printf "%-56s" "Generating config file... "
# START: Danube Cloud service VM IPs

{% if usb_type == "hn" %}
# Calculate admin network
ip_netmask_to_network "$admin_ip" "$admin_netmask"
num_to_ip $NET_NUM
admin_network="$ip_addr"

# Calculate admin network address for every core zone.
ip_netmask_to_network "$mgmt_admin_ip" "$admin_netmask"

next_addr=$(($IP_NUM + 1))
num_to_ip "$next_addr"
mon_admin_ip="$ip_addr"

next_addr=$(($next_addr + 1))
num_to_ip "$next_addr"
dns_admin_ip="$ip_addr"

next_addr=$(($next_addr + 1))
num_to_ip "$next_addr"
img_admin_ip="$ip_addr"

next_addr=$(($next_addr + 1))
num_to_ip "$next_addr"
cfgdb_admin_ip="$ip_addr"
{% endif %}
# END: Danube Cloud service VM IPs


tmp_config=/tmp/config
touch $tmp_config
chmod 600 $tmp_config

echo "#" >$tmp_config
echo "# This file was auto-generated and must be source-able by bash." \
    >>$tmp_config
echo "#" >>$tmp_config
echo >>$tmp_config

# If in a VM, setup coal so networking will work.
platform=$(smbios -t1 | nawk '{if ($1 == "Product:") print $2}')
[ "$platform" == "VMware" ] && echo "coal=true" >>$tmp_config

echo "admin_nic=$admin_nic" >>$tmp_config
echo "admin_vlan_id=$admin_vlan_id" >>$tmp_config
echo "admin_ip=$admin_ip" >>$tmp_config
if [[ "$admin_ip" != "dhcp" ]]; then
	echo "admin_netmask=$admin_netmask" >>$tmp_config
	{% if usb_type == "hn" %}
	echo "admin_network=$admin_network" >>$tmp_config
	{% endif %}
	echo >>$tmp_config
fi
echo "admin_gateway=$admin_gateway" >>$tmp_config

if [[ "$headnode_default_gateway" != "none" ]]; then
	echo "headnode_default_gateway=$headnode_default_gateway" >>$tmp_config
	echo >>$tmp_config
fi

echo "dns_resolvers=$dns_resolver1,$dns_resolver2" >>$tmp_config
echo "dns_domain=$dns_domain" >>$tmp_config
echo >>$tmp_config

echo "ntp_hosts=$ntp_hosts" >>$tmp_config
echo "compute_node_ntp_hosts=$admin_ip" >>$tmp_config
echo >>$tmp_config

echo "hostname=$hostname" >>$tmp_config
echo >>$tmp_config

# add rest of NIC tags
for ntag in "${!nictag_macs[@]}"; do
	echo "${ntag}_nic=${nictag_macs[$ntag]}" >>$tmp_config
	if [[ -n ${nictag_ips[$ntag]} ]]; then
		echo "${ntag}0_vlan_id=${nictag_vlans[$ntag]}" >>$tmp_config
		echo "${ntag}0_ip=${nictag_ips[$ntag]}" >>$tmp_config
		echo "${ntag}0_netmask=${nictag_netmasks[$ntag]}" >>$tmp_config
	fi
done

# START: Danube Cloud settings
echo >>$tmp_config
echo "# Danube Cloud settings" >>$tmp_config
echo "datacenter_name='${datacenter_name}'" >>$tmp_config
{% if usb_type == "hn" %}
echo "admin_email='${admin_email}'" >>$tmp_config
echo "mgmt_admin_ip=${mgmt_admin_ip}" >>$tmp_config
echo "mon_admin_ip=${mon_admin_ip}" >>$tmp_config
echo "dns_admin_ip=${dns_admin_ip}" >>$tmp_config
echo "img_admin_ip=${img_admin_ip}" >>$tmp_config
{% endif %}
echo "cfgdb_admin_ip=${cfgdb_admin_ip}" >>$tmp_config
echo "esdc_install_password='${esdc_install_password}'" >>$tmp_config
echo "install_to_hdd=${install_to_hdd}" >>$tmp_config
echo  >>$tmp_config
# END: Danube Cloud settings
printf "%4s\n" "done"

create_zpools "$DISK_LAYOUT"

printf "%-56s" "Saving /usbkey/config... "
mv $tmp_config /usbkey/config || fatal "failed to persist configuration"
printf "%4s\n" "done"

# set the root password
printf "%-56s" "Saving /usbkey/shadow... "
root_shadow=$(/usr/lib/cryptpass "$root_shadow")
sed -e "s|^root:[^\:]*:|root:${root_shadow}:|" /etc/shadow > /usbkey/shadow \
      && chmod 400 /usbkey/shadow
[[ $? -eq 0 ]] || fatal "failed to preserve root password"
printf "%4s\n" "done"

if [[ ${install_to_hdd} -eq 1 ]]; then
	printf "%-56s" "Saving /etc/shadow... "
	sed -e "s|^root:[^\:]*:|root:${root_shadow}:|" ${TMPROOT}/etc/shadow > ${TMPROOT}/etc/shadow.new \
		&& chmod 400 ${TMPROOT}/etc/shadow.new \
		&& mv ${TMPROOT}/etc/shadow.new ${TMPROOT}/etc/shadow
	[[ $? -eq 0 ]] || fatal "failed to set root password"
	printf "%4s\n" "done"
fi

printf "%-56s" "Saving /usbkey/ssh... "
cp -rp /etc/ssh /usbkey/ssh || fatal "failed to set up preserve host keys"
printf "%4s\n" "done"

sync
sleep 1

if [[ ${install_to_hdd} -eq 1 ]]; then
    echo
    echo "==> Please remove the USB flash drive and press [enter] to continue."
    read PAUSE
fi

# Do not perform a reboot when netboot_install_script boot parameter is specified
if ! /bin/bootparams | grep -q "^netboot_install_script="; then
	echo "==> The system will now finish configuration and reboot in 10 seconds."
	echo "==> Please wait..."
	sleep 10
	reboot > /dev/null 2> /dev/null
fi
